name: Build and Test
on:
  workflow_call:
    secrets:
      SIEMENS_NPM_TOKEN:
        required: true
      SIEMENS_NPM_USER:
        required: true
      MAPTILER_KEY:
        required: true
  pull_request:

# Stops the workflow run if the PR is updated
# https://stackoverflow.com/a/72408109
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

env:
  MAPTILER_KEY: ${{ secrets.MAPTILER_KEY }}
  MAPTILER_URL: https://api.maptiler.com/maps/voyager/style.json?key=${{ secrets.MAPTILER_KEY }}

jobs:
  build:
    runs-on: ubuntu-24.04
    steps:
      - uses: actions/checkout@v5
        with:
          fetch-depth: 0 # We need this for commit-lint
      - uses: actions/setup-node@v4
        with:
          node-version: lts/jod
          cache: 'npm'
      - run: npm config set //code.siemens.com/api/v4/packages/npm/:_authToken $SIEMENS_NPM_TOKEN
        env:
          SIEMENS_NPM_TOKEN: ${{ secrets.SIEMENS_NPM_TOKEN }}
      - run: npm ci --prefer-offline --no-audit --include=optional
      - run: npm run lint:commit
      - run: npm run build:all
      - run: npm run prepare-brand
      - run: npm run build:all:update-translatable-keys # Output is needed in dist for providing default translations
      - run: git diff --exit-code "projects/**/*-translatable-keys.interface.ts"
      - run: npm run build:examples --define="maptilerKey='$MAPTILER_KEY'" --define="maptilerUrl='$MAPTILER_URL'"
      - run: npm run dashboards-demo:build:demo -- --progress=false
      - run: npm run dashboards-demo:build:webcomponents -- --progress=false
      - run: npm run dashboards-demo:build:mfe -- --progress=false
      - uses: actions/upload-artifact@v4
        with:
          name: dist
          path: dist

  test:
    runs-on: ubuntu-24.04
    # We use playwright browser to run karma tests
    container: mcr.microsoft.com/playwright:v1.54.2-noble
    env:
      # See: https://github.com/microsoft/playwright/issues/27620
      HOME: /root
    needs:
      - build
    steps:
      - uses: actions/checkout@v5
      - uses: actions/setup-node@v4
        with:
          node-version: lts/jod
          cache: 'npm'
      - uses: actions/download-artifact@v5
        with:
          name: dist
          path: dist
      - run: npm ci --prefer-offline --no-audit
      - run: npm run lint:format
      - run: npm run lint:scss
      - run: npm run lint:ng
      - run: npm run lint:playwright:eslint
      - run: npm run translate:test -- --watch=false --progress=false --code-coverage
      - run: npm run lib:test -- --watch=false --progress=false --code-coverage
      - run: npm run charts:test -- --watch=false --progress=false
      - run: npm run dashboards:test -- --watch=false --progress=false
      # TODO: Upload coverage reports

  aot:
    runs-on: ubuntu-24.04
    needs:
      - build
    steps:
      - uses: actions/checkout@v5
      - uses: actions/setup-node@v4
        with:
          node-version: lts/jod
          cache: 'npm'
      - uses: actions/download-artifact@v5
        with:
          name: dist
          path: dist
      - run: npm config set //code.siemens.com/api/v4/packages/npm/:_authToken $SIEMENS_NPM_TOKEN
        env:
          SIEMENS_NPM_TOKEN: ${{ secrets.SIEMENS_NPM_TOKEN }}
      - run: npm ci --prefer-offline --no-audit --include=optional
      - run: npm run prepare-brand
      - run: npm run build:examples:aot --define="maptilerKey='$MAPTILER_KEY'" --define="maptilerUrl='$MAPTILER_URL'"

  e2e:
    runs-on: ubuntu-24.04
    container: mcr.microsoft.com/playwright:v1.54.2-noble
    needs:
      - build
    strategy:
      fail-fast: false
      matrix:
        shardIndex: [1, 2]
        shardTotal: [2]
    steps:
      # As we are in another container, we need to install LFS manually.
      # See: https://github.com/orgs/community/discussions/160433
      - name: Install LFS
        run: |
          git config --global --add safe.directory "$GITHUB_WORKSPACE"
          curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | bash
          apt install git-lfs
      - uses: actions/checkout@v5
        with:
          lfs: true
      - uses: actions/setup-node@v4
        with:
          node-version: lts/jod
          cache: 'npm'
      - uses: actions/download-artifact@v5
        with:
          name: dist
          path: dist
      # Not injecting the token will exclude the brand packages, but this is fine for e2e tests.
      - run: npm ci --prefer-offline --no-audit --include=optional
      - run: npx playwright test --shard=${{ matrix.shardIndex }}/${{ matrix.shardTotal }}
      - uses: actions/upload-artifact@v4
        if: ${{ !cancelled() }}
        with:
          name: blob-report-${{ matrix.shardIndex }}
          path: blob-report
          retention-days: 1

  generate-snapshots:
    runs-on: ubuntu-24.04
    container: mcr.microsoft.com/playwright:v1.54.2-noble
    needs:
      - build
    if: github.event_name == 'workflow_dispatch' || (github.event_name == 'pull_request' && github.run_attempt > 1)
    steps:
      - name: Check execution conditions and set target ref
        id: check
        run: |
          echo "should-run=true" >> $GITHUB_OUTPUT
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "target-ref=${{ inputs.ref }}" >> $GITHUB_OUTPUT
          else
            # For PR re-runs, use the head ref
            echo "target-ref=${{ github.head_ref }}" >> $GITHUB_OUTPUT
          fi

      - name: Get latest workflow run
        id: get-workflow
        uses: actions/github-script@v7
        with:
          script: |
            const { data: runs } = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'build-and-test.yaml',
              branch: '${{ steps.check.outputs.target-ref }}',
              per_page: 10,
              status: 'completed'
            });

            if (runs.total_count === 0) {
              core.setFailed(`No completed workflow runs found for branch '${{ steps.check.outputs.target-ref }}'. Make sure the build-and-test workflow has run on this branch.`);
              return;
            }

            // Find the most recent run that has the required jobs completed successfully
            const requiredJobs = ['build', 'test', 'aot'];
            let latestValidRun = null;

            for (const run of runs.workflow_runs) {
              try {
                // Get jobs for this workflow run
                const { data: jobs } = await github.rest.actions.listJobsForWorkflowRun({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  run_id: run.id
                });

                // Check if all required jobs completed successfully
                const jobStatuses = {};
                for (const job of jobs.jobs) {
                  jobStatuses[job.name] = job.conclusion;
                }

                console.log(`Checking run ${run.id}: Jobs found:`, Object.keys(jobStatuses));
                console.log(`Job statuses:`, jobStatuses);

                const allRequiredJobsSuccessful = requiredJobs.every(jobName => 
                  jobStatuses[jobName] === 'success'
                );

                if (allRequiredJobsSuccessful) {
                  latestValidRun = run;
                  break;
                } else {
                  const failedJobs = requiredJobs.filter(jobName => 
                    !jobStatuses[jobName] || jobStatuses[jobName] !== 'success'
                  );
                  console.log(`❌ Run ${run.id} missing or failed jobs:`, failedJobs);
                }
              } catch (error) {
                console.log(`Error checking run ${run.id}:`, error.message);
                continue;
              }
            }

            if (!latestValidRun) {
              core.setFailed(`No workflow runs found for branch '${{ steps.check.outputs.target-ref }}' with successful completion of required jobs: ${requiredJobs.join(', ')}. Make sure build, test, and aot jobs have completed successfully.`);
              return;
            }

            core.setOutput('workflow-run-id', latestValidRun.id);
            core.setOutput('workflow-status', latestValidRun.conclusion);

            // Create a summary of what we found
            const { data: jobs } = await github.rest.actions.listJobsForWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: latestValidRun.id
            });

            const requiredJobStatuses = requiredJobs.map(jobName => {
              const job = jobs.jobs.find(j => j.name === jobName);
              return `${jobName}: ${job ? job.conclusion : 'not found'}`;
            }).join(', ');

            core.notice(`Using workflow run ${latestValidRun.id} | Required jobs status: ${requiredJobStatuses}`);

      # As we are in another container, we need to install LFS manually.
      # See: https://github.com/orgs/community/discussions/160433
      - name: Install LFS
        run: |
          git config --global --add safe.directory "$GITHUB_WORKSPACE"
          curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | bash
          apt install git-lfs -y

      - name: Configure Git
        run: |
          git config --global user.email "action@github.com"
          git config --global user.name "GitHub Action"
          git config --global --add safe.directory "$GITHUB_WORKSPACE"

      - uses: actions/checkout@v5
        with:
          ref: ${{ steps.check.outputs.target-ref }}
          lfs: true

      - uses: actions/setup-node@v4
        with:
          node-version: lts/jod
          cache: 'npm'

      - uses: actions/download-artifact@v5
        with:
          name: dist
          path: dist
      # Not injecting the token will exclude the brand packages, but this is fine for e2e tests.
      - run: npm ci --prefer-offline --no-audit --include=optional

      - name: Generate fresh snapshots
        run: |
          # Remove existing snapshots to ensure we generate fresh ones
          if [ -d "playwright/snapshots" ]; then
            echo "Removing existing snapshots to ensure fresh generation..."
            rm -rf playwright/snapshots
          fi

          # Create snapshots directory
          mkdir -p playwright/snapshots

          echo "Starting fresh snapshot generation..."
          npx playwright test --update-snapshots=all

          # Verify that snapshots were generated
          if [ ! -d "playwright/snapshots" ] || [ -z "$(ls -A playwright/snapshots 2>/dev/null)" ]; then
            echo "ERROR: No snapshots were generated!"
            exit 1
          fi

          echo "Snapshots generated successfully:"
          find playwright/snapshots -type f -name "*.png" | head -10
        env:
          PLAYWRIGHT_CONTAINER: true
          PLAYWRIGHT_isvrt: 'true'
          PLAYWRIGHT_isa11y: 'false'
          PLAYWRIGHT_WEB_SERVER_TIMEOUT: 120000

      - name: Create snapshots archive
        run: |
          # Verify that snapshots exist and were recently modified
          if [ ! -d "playwright/snapshots" ]; then
            echo "ERROR: playwright/snapshots directory does not exist!"
            exit 1
          fi

          SNAPSHOT_COUNT=$(find playwright/snapshots -type f -name "*.png" | wc -l)
          if [ "$SNAPSHOT_COUNT" -eq 0 ]; then
            echo "ERROR: No snapshot files found in playwright/snapshots!"
            exit 1
          fi

          echo "Found $SNAPSHOT_COUNT snapshot files"
          echo "Recent snapshot files:"
          find playwright/snapshots -type f -name "*.png" -mmin -60 | head -5

          # Create a timestamped archive of the updated snapshots
          TIMESTAMP=$(date +"%Y%m%d-%H%M%S")
          BRANCH_NAME="${{ inputs.ref || github.ref_name }}"

          # Sanitize branch name by replacing invalid characters for artifact names
          # Replace forward slashes, colons, and other invalid characters with hyphens
          SAFE_BRANCH_NAME=$(echo "$BRANCH_NAME" | sed 's/[\/\\:*?"<>|]/-/g')

          ARCHIVE_NAME="playwright-snapshots-${SAFE_BRANCH_NAME}-${TIMESTAMP}"

          # Create archive directory structure
          mkdir -p "${ARCHIVE_NAME}"
          cp -r playwright/snapshots "${ARCHIVE_NAME}/"

          # Verify the copy was successful
          COPIED_COUNT=$(find "${ARCHIVE_NAME}/snapshots" -type f -name "*.png" | wc -l)
          echo "Copied $COPIED_COUNT snapshot files to archive"

          if [ "$COPIED_COUNT" -ne "$SNAPSHOT_COUNT" ]; then
            echo "WARNING: Snapshot count mismatch! Original: $SNAPSHOT_COUNT, Copied: $COPIED_COUNT"
          fi

          # Add metadata file
          cat > "${ARCHIVE_NAME}/snapshot-info.txt" << EOF
          Generated on: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          Branch/Ref: ${BRANCH_NAME}
          Commit SHA: ${{ github.sha }}
          Workflow Run: ${{ github.run_id }}
          Generated from workflow run: ${{ steps.get-workflow.outputs.workflow-run-id }}
          Total snapshot files: ${SNAPSHOT_COUNT}
          EOF

          # Create tar.gz archive
          tar -czf "${ARCHIVE_NAME}.tar.gz" "${ARCHIVE_NAME}"

          echo "ARCHIVE_NAME=${ARCHIVE_NAME}" >> $GITHUB_ENV
          echo "Archive created: ${ARCHIVE_NAME}.tar.gz"

      - name: Upload fresh snapshots
        id: upload-artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.ARCHIVE_NAME }}
          path: ${{ env.ARCHIVE_NAME }}.tar.gz
          retention-days: 30

      - name: Get artifact download URL
        if: success()
        id: artifact
        uses: actions/github-script@v7
        with:
          script: |
            // Wait a bit for the artifact to be uploaded and indexed
            await new Promise(resolve => setTimeout(resolve, 5000));

            const downloadUrl = "${{ steps.upload-artifact.outputs.artifact-url }}";

            core.setOutput('download_url', downloadUrl);

      - name: Comment on PR with download link
        if: success() && github.event_name == 'pull_request'
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          message: |
            [⬇️ Download Snapshots](${{ steps.artifact.outputs.download_url }})

  e2e-merge-reports:
    if: ${{ !cancelled() }}
    needs: [e2e]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
      - uses: actions/setup-node@v4
        with:
          node-version: lts/jod
      - uses: actions/download-artifact@v5
        with:
          path: all-blob-reports
          pattern: blob-report-*
          merge-multiple: true
      - run: npx playwright merge-reports --reporter html ./all-blob-reports
      - uses: actions/upload-artifact@v4
        with:
          name: html-report--attempt-${{ github.run_attempt }}
          path: playwright-report
          retention-days: 2

  documentation:
    runs-on: ubuntu-24.04
    needs:
      - build
    steps:
      - uses: actions/checkout@v5
      - uses: astral-sh/setup-uv@v6
      - uses: actions/download-artifact@v5
        with:
          name: dist
          path: dist
      - uses: actions/setup-node@v4
        with:
          node-version: lts/jod
          cache: 'npm'
      - run: npm config set //code.siemens.com/api/v4/packages/npm/:_authToken $SIEMENS_NPM_TOKEN
        env:
          SIEMENS_NPM_TOKEN: ${{ secrets.SIEMENS_NPM_TOKEN }}
      - run: npm ci --prefer-offline --no-audit --include=optional
      - run: cp dist/element-examples/favicon.png docs/_src/favicon.png
      # uv sync in custom location to avoid issues with commonJS for JSPYBrdige
      - run: mkdir -p /opt/uv/
      - run: uv venv
        working-directory: /opt/uv
      - run: uv sync --active
        env:
          VIRTUAL_ENV: '/opt/uv/.venv'
          UV_INDEX_CODE_DOCS_THEME_USERNAME: ${{ secrets.SIEMENS_NPM_USER }}
          UV_INDEX_CODE_DOCS_THEME_PASSWORD: ${{ secrets.SIEMENS_NPM_TOKEN }}
      - run: npm run docs:build:generate
        env:
          VIRTUAL_ENV: '/opt/uv/.venv'
          EXAMPLES_BASE: /element-examples
        if: ${{ github.ref == 'refs/heads/main' }}
      - run: npm run docs:build:api
        env:
          VIRTUAL_ENV: '/opt/uv/.venv'
          EXAMPLES_BASE: /element-examples
        if: ${{ github.ref != 'refs/heads/main' }}
      - run: mv dist/element-examples/ dist/design/
      - run: mv dist/dashboards-demo/ dist/design/
      - uses: actions/upload-artifact@v4
        with:
          name: pages
          path: dist/design
